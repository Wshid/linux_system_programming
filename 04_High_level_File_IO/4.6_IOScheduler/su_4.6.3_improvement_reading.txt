읽으려면 반드시 최신데이터 반환
    -> 요청한 데이터가 페이지 캐시에 존재하지 않으면,
        디스크에서 읽어올때까지 블록
    -> Read Latency

일반적인 어플리케이션은 짧은 시간동안 여러차례 읽기 입출력 요청을 보냄
    각 요청은 독립적으로 동기화, 나중에 들어온 요청은 앞선 요청 완료에 의존적

모든 요청이 직렬와 되어, 다음 요청은 현재 요청이 완료될때까지 처리되지 않음

특정 시점까지는 디스크 입출력이 불필요한 쓰기요청(기본적으로 비동기화 상태)
    과는 아주 대조적임

사용자 영역 app에서 쓰기요청은 디스크 성능에 방해되지 않는 스트림 사용

쓰기 스트림이 커널과 디스크 독차지
    -> writes-starving-reads problem (쓰기가 읽기를 굶겨 죽이는 문제)


리누스 엘리베이터 // 큐에 오래된 요청 있으면 멈춤
    -> 전체 희생, 공정성 유지


데드라인 입출력 스케줄러
    리누스 엘리베이터 큐 // 들어온 순서에 따라 정렬
    Read FIFO Queue // 읽기 요청 중 들어온 순서에 따라 // 만료 : 5ms
    Write FIFO Queue // 쓰기 요청 중 들어온 순서에 따라 // 만료 : 5sec

만료 전에는 리누스 엘리베이터 큐에서 처리하다가
    만료시, 해당 FIFO Queue에서 직접 처리


예측 입출력 스케줄러
    한 app에서 읽기 요청만 과다하게 요청한다면?
        - 전체 큐에서는 계속 뒤에 배치
        - Read 큐에서는 계속 채워짐
            -> 만료시간 도래, 읽기 큐에서 처리
        - 다시 전체큐로 돌아와서 읽다가
            -> 만료시간 도래, 읽기 큐에서 처리
            
        번거로운 작업 반복

    데드라인 입출력 큐에서
        읽기 요청시, 평소처럼 처리후,
            6ms까지 그냥 기다림
                -> 동일한 부분에 예측할 수 있는 시간
            입력 요청이 안온다면, 다시 표준 큐로 돌아감


CFQ 입출력 스케줄러(Complete Fair Queueing) -> 가장 먼저 적용해볼 방식
    프로세스마다 독자적인 큐 사용
    각 큐는 시간을 할당 받음
    RR방식으로 동작
        큐에 허락된 시간 만료 / 요청이 남지 않을때까지
    
    큐에 작업 없을경우 10ms(기본값)을 기다림
    예측 실패시 다음큐
    
    Priority : 동기화된 요청(read) > 비동기화 요청
    
전체 성능 좋게 유지하면서, 공정하게 동작함


Noop 입출력 스케줄러
    SSD(Solid-State Drive)에서 주로 사용
        RAM과 크게 다르지 않음
            연속된 데이터 한번에 읽기 가능
            데이터의 디스크 위치 상관없이 접근하는데 추가시간 x
    정렬x
    병합만 수행