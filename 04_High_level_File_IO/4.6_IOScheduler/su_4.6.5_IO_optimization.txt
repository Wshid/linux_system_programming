성능 향상 시키기
    연산 갯수 최소화 // 자잘한 연산 병합
    입출력 블록 크기 정렬
    사용자 버퍼링
    벡터 입출력
    위치를 지정한 입출력
    비동기식 입출력
    

사용자 영역에서 입출력 스케줄링하기
    -> 입출력 많이 요구하는 중요한 app에서만 적용
        => 아닐 경우, 불필요한 낭비


IO Scheduler가 블록 단위 정렬
    디스크 헤드 불필요한 탐색 최소화

왜 굳이 사용자 영역에서까지?

매우 많고 정렬되지 않은 IO요청을 하는 app일때
    무작위로 IO Scheduler의 큐에 들어감
        정렬, 병합후 디스크로
            app에서 입출력 생성중인데 IO Scheduler가 요청을 디스크로 보내버릴 수 있음
                IO Scheduler가 한번에 정렬할 수 있는 요청은
                    전체 요청 중 일부


전체 데이터에 대한 요청을 생성 한다면,
    요청 전에 정렬
        IO Scheduler에 원하는 순서대로 보낼 수 있음


사용자 app에서는 kernel과 동일한 정보 접근 불가능
    IO 내부 // 물리적인 디스크 블록
    사용자 영역 // 파일+offset
        -> 추측만이 답
    
    파일의 전체 경로, inode 번호, 파일의 물리적인 디스크 블록


경로로 정렬하기 -> 쉽지만, 효과 낮음
    동일 디렉터리 내 파일과 디렉터리들은
        디스크에서 인접하는 경향이 있음
    동일 시간 + 동일 dir 내 -> 확률 높음

    물리적인 위치 유추가 가능함
    단, 파편화 고려가 없음
        -> 파편화 심할수록 효과가 미미함
        -> 실제 블록 단위 순서의 근사값 유추 가능
    모든 fs에 적용 가능한 방법

inode로 정렬하기
    inode : 개별 파일과 관련된 meta-data를 담고 있는 unix 구성요소
        모든 파일은 고유적인 inode num.을 가지고 있음
    
    i.inode < j.inode
        i.phy.block < j.phy.block
    
    inode번호는 stat() sys.call을 통해 활용이 가능
        -> 각 입출력 요청과 관련된 파일의 inode번호를 가지고 오름차순 정렬

    inode번호는 쉽게 얻을 수 있음
        정렬도 쉬움
        물리적인 파일 배치를 추측하기가 쉬움
    
    파편화에 따라 추측 오류
    유닉스 아닐경우 정확도 낮음

물리 블록 정렬
    각 파일은
        논리 블록 단위로 쪼개짐 // fs에서 가장 작은 할당 단위
    
    논리블록은 물리블록과 맵핑됨
    
    파일이 차지하고 있는 논리블록을 찾아
        어떤 물리블록에 맵핑되어 있는지 확인하는 방법
    
    ioctl의 FIBMAP 명령으로 수행
        ret=ioctl(fd, FIBMAP, &block); // block은 논리블록, 성공시 물리블록으로 리턴
        if(ret<0) perror("ioctl");
        
        block의 경우 파일에 상대적인 값
            파일이 8개 논리블록이라면, 0~7값 중 하나
        
    파일은 연속적인 경향
    입출력 요청을 논리블록 기준으로 정렬하는 것은 어려움
        첫번째 논리 블록의 위치를 기준하여 정렬하면?
            get_nr_blocks()는 필요가 없어짐
            
            get_block(fd, 0);
    

FIBMAP은 CAP_SYS_RAWIO 기능 요구 // root 권한 필요
FIBMAP은 ext2, ext3에서 지원하지만, 잘 사용하지 않는 희소 fs에서는 지원 x
    ioctl은 EINVAL 반환 // 지원하지 않는 다면,

정확히 정렬하고 싶은 대상인, 파일 실제 존재 물리 디스크 블록 반환
    -> 이상적인 방법가 가장 가까움
    