블록 = fs의 최소저장 단위 // 추상적인 개념
모든 입출력 연산은 블록 크기의 정수배에 맞춰서 일어난다.
    1byte만을 기록하더라도, 1블록을 사용하게 됨

블록 일부분만 다루는 연산이 매우 비효율적
    1. dd bs=1 count=2097152 if=/dev/zero of=pirate // 1바이트씩 2,097,152번 연산
    2. dd bs=1024 count 2048 if=/dev/zero of=pirate // 1024바이트씩 2048번 연산
        1번보다 2번이 빠르다는 것을 알 수 있음
    
    /dev/zero : 0이 담긴 끝없는 스트림을 제공하는 가상 디바이스

블록크기의 배수로 연산을 수행하지 않으면 성능 저하가 발생
    1,024가 1,130씩 연산하는 것보다 빠름

    => 성능개선을 위해 물리 블록 크기를 알고 있어야 함
        => 물론 크기는 1,024의 배수 또는 약수 일 것


=== 3.1.1 Block size

실제 블록 크기는 512, 1,024 2,048, 4,096 8,192 중에 하나
블록 사이즈에 맞게 연산을 진행하면 속도가 빨라짐
    커널과 하드웨어가 블록 크기를 기준으로 대화하기 때문

stat() : 특정 디바이스의 블록 크기
    stat(1) 명령어 사용

입출력 연산을 모두 블록 크기에 맞추면 성능이 좋아진다.
    더 큰 배수로 지정시, System call을 사용하는 횟수가 더 줄어든다.

보통은 일반적인 블록크기의 정수배 크기의 버퍼 사용
    -> 4096이나 8192 사용


하지만 모든 데이터를 블록 크기의 정수배로 하기엔 어려움 => 사용자 버퍼 입출력이 필요한 이유
    사용자 버퍼 입출력 : 블록 단위로 동작하는 fs <-> 다른 추상개념을 가진 App

사용자 입력(Application)    ->  버퍼(Buffer)    -> 디스크(Disk)
    특정 크기(Block size)에 도달하면 디스크의 기록하기 시작
    
프로그램 내부에서 직접 사용자 버퍼링 구현도 가능

대다수 프로그램에서는 C에서의 stdio.h나 C++의 iostream을 활용한다.