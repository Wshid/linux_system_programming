COW(Copy-on-Write)
parent ps의 주소공간 모두 복사하는 것이 아닌,
    페이지에 대한 복사를 의미

지연 최적화(lazy optimization)
    리소스에 대한 읽기 요청이 여러곳에서 발생하더라도, 
        그 리소스에 대한 복사본 만들 필요 없으며,
            단순히 그 리소스에 대한포인터만 넘겨받으면 된다
    
    포인터가 가리키는 리소스 변경이 없는 이상
        리소스 복사를 하지 않음
    리소스 변경이 일어날 시, 해당 리소스는 복사됨
    
즉, 쓰기 작업을 할 경우에만 복사가 일어남 -> copy-on-write

복사본에 대한 변경이 필요 없을때, 복사가 일어나지 않음
    -> 필요한 시점까지 비용이 높은 연산을 미루는, 지연 알고리즘의 장점


가상 메모리, 페이지 기반으로 구현됨
    fork()완료시,
        부모와 자식 ps는
            부모 ps의 원본 페이지를 공유하고 있으며,
                공유하고 있는 페이지 역시, 다른 부모, 자식 ps와 공유


커널의 페이지 관련 자료 구조내, 읽기 전용, copy-on-write로 표시됨
    특정 ps가 변경 시도시, page fault 발생,
        커널은 pf.를 처리하기 위해 페이지 복사 후
            해당 페이지의 copy-on-write 속성이 비워지면서
                더 이상 공유되지 않음

copy-on-write는 fork()사용시 이득
    대부분 fork 이후 exec이기 때문에
        부모 ps의 주소공간을 자식 ps의 주소공간으로 복사는 낭비
    자식 ps가 새로운 bin. image 생성시, 이전의 주소공간은 필요 없음
        copy-on-write에서 최적화 함


=== vfork
    fork()이후 exec가 이어지면 쓸모없는 주소공간을 복사한다.
        -> 이점을 해결하기 위해 개발됨
        
#include<sys/types.h>
#include<unistd.h>

pid_t vfork(void);

fork()와 같은 동작을 하나, 자식 ps는
    exec()함수를 호출 | _exit()함수를 호출하여 ps를 끝내야함

자식 ps가 종료되거나, 새로운 bin. image를 실행할때까지
    부모 ps를 멈춰둔다
        -> 프로세스 주소공간, 페이지 테이블 복사를 회피

버그가 있음
    exec()호출 실패시.. 계속 멈춰있게 됨